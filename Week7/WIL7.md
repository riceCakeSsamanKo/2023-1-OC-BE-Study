# 5개 원칙

## SRP : 단일 책임 원칙
한 클래스는 하나의 책임만 가져야한다.
변경시 파급효과가 적으면 단일 책임 원칙을 잘 따른 것

단일 책임 원칙을 잘 따르는 경우 하나의 클래스가 하나만을 확실히 책임지게 되어 만일 어떠한 변경사항이 발생했을 때,
해당 클래스 한 부분만 고치면 된다. 만일 SRP를 잘 따르지 않는 경우.. 즉, 하나의 클래스가 지나치게 많은 역할, 책임을 담당하는 경우 클래스 내부에서 다른 부분과 강하게 결합될 가능성이 높아지게 되고 그럴 경우에는 코드의 한 부분을 수정할 때 다른 부분에도 영향을 미칠 가능성이 높아지게 된다. 결과적으로 유지 보수성이 낮아진다. 따라서 단일 책임 원칙을 준수하는 경우 코드의 유지보수성이 올라간다. 

## OCP : 개방 폐쇄 원칙
기존 코드를 변경하지 않는 것.
다형성을 활용해 확장에는 열려있으나 변경에는 닫혀있도록한다.
다형성만 가지고는 OCP 원칙을 지킬수 없다.
객체를 생성하고 연관관계를 맺어주는 별도의 조립, 설정자가 필요.

OCP는 추상화를 하는 것이라고 생각하면 편한데, 추상화를 했을 때 장점은 다음과 같다. 어떠한 기능이 추가가 된다고 하더라도 클래스의 수정이 필요 없다.
abstract class Animal {
    abstract void speak();
}

class Cat extends Animal { // 상속
    void speak() {
        System.out.println("냐옹");
    }
}

class Dog extends Animal { // 상속
    void speak() {
        System.out.println("멍멍");
    }
}

class HelloAnimal {
    void hello(Animal animal) {
        animal.speak();
    }
}

public class Main {
    public static void main(String[] args) {
        HelloAnimal hello = new HelloAnimal();

        Animal cat = new Cat();
        Animal dog = new Dog();

        hello.hello(cat); // 냐옹
        hello.hello(dog); // 멍멍
    }
}
위 처럼 Animal 클래스를 추상 클래스로 설정하고 이를 Cat과 Dog가 상속 받는다면 각각 speak() 함수를 구현한다면 hello.hello() 함수의 인자로 만일 Cat과 Dog가 아닌 다른 Lion과 같이 새로 생성된 인스턴스가 추가된다고 하더라도 HelloAnimal 클래스 자체는 수정이 필요없이 기능 확장이 된다.

## LSP : 리스코프 치환 원칙
인터페이스의 규약이 존재한다면 하위 클래스는 무조건 그 규약을 지켜야함.
예를 들어 엑셀을 밟으면 앞으로 간다라고 했으면, 하위 클래스에선 무조건 이를 
따라야한다. 
엑셀 밟으면 뒤로가는 식으로 구현하면 안된다는 말. 
컴파일 되고 안되고의 문제가 아닌 구현을 하는데 있어서 
기존의 원칙을 위반해서는 안된다는 것.

## ISP : 인터페이스 분리 원칙
특정 클라이언트를 위한 인터페이스 여러개가 범용 인터페이스 하나보다 낫다.
인터페이스가 분리될수록 유지,보수에 유리하고 인터페이스가 명확해짐.

## DIP : 의존관계 역전 원칙

추상화에 의존해야지, 구체화에 의존해서는 안된다.
구현 클래스에 의존하지 말고, 인터페이스에 의존해야한다.